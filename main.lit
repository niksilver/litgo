@title Litgo - A literate programming processor written in Go

@code_type Go .go
@comment_type // %s


@s Application structure

--- main.go
package main

import (
    @{Imports}
)

@{Package level declarations}

@{Functions}
---


@s Processing content: Basic structure

We start with a slice of bytes (or input) but it will be processed
line by line, as strings.
We will do this by maintaining a state, and process each line by
updating the state.

Each line will be received for processing without its end of line characters.

--- Imports
"bufio"
"fmt"
"github.com/gomarkdown/markdown"
"strings"
---

--- Package level declarations
type state struct {
    markdown strings.Builder
    lineNum int
    @{More state fields}
    proc func(s *state, line string)
}

---

--- Functions
func newState() state {
    return state{
        @{Field initialisers for state}
    }
}

func processContent(c []byte, s *state) {
    r := strings.NewReader(string(c))
    sc := bufio.NewScanner(r)
    for sc.Scan() {
        s.proc(s, sc.Text())
    }
    @{Tidy-up after processing content}
}

func main() {
    input := []byte("# Hello world\n\nThis is my other literate document")
    s := newState()
    processContent(input, &s)
    md := []byte(s.markdown.String())
	output := markdown.ToHTML(md, nil, nil)
	fmt.Println(string(output))
    //@{Check code chunks}
}

---

For the purposes of both testing and ease of developing our application
we need a generic way of reacting to lines. The process is:

    Line ->    Code processor    ->  Markdown processor
            (May add more lines,
             or drop this line,
             or change the input
             in other ways)

The code processor, which is `proc` in the code above,
should just pass through any markdown, but it
will need to process special commands and it will need to keep a
track of the code as it is assembled in non-linear order.

We will also make `proc` a field of the state struct so that it can
be overridden in tests.

--- Functions +=
func proc(s *state, line string) {
    s.lineNum ++
    @{Collect lines in code chunks}
    @{Send surviving lines to markdown}
}

---

--- Field initialisers for state
proc: proc,
---


@s Processing content: Errors and warnings

As part of our evolving processing state we will collect warnings,
such as a chunk appearing without a name. We may also have to stop
at an error. Both are kinds of problems. Warnings will be problems
collected in the state; an error will be returned from any processing.

--- Package level declarations +=
type problem struct {
    line int
    msg string
}

---

--- More state fields
warnings []problem
---


@s Processing content: Collect lines in code chunks

Code chunks start with three backticks, a space, and a name.
They end with three backticks.
Anything within the backticks is to be generated code, and that code
will go into a map, from name to code.
We'll assemble the chunks later.

--- More state fields +=
inChunk bool
chunkName string
code map[string]strings.Builder
---

--- Field initialisers for state +=
code: make(map[string]strings.Builder),
---

--- Collect lines in code chunks
if s.inChunk && line == "```" {
    s.inChunk = false
} else if s.inChunk {
    b := s.code[s.chunkName]
    b.WriteString(line + "\n")
    s.code[s.chunkName] = b
} else if !s.inChunk && strings.HasPrefix(line, "```") {
    s.chunkName = strings.TrimSpace(line[3:])
    if s.chunkName == "" {
        s.warnings = append(s.warnings, problem{ s.lineNum, "Chunk has no name"})
    }
    s.code[s.chunkName] = strings.Builder{}
    s.inChunk = true
}
---

--- Tidy-up after processing content
if s.inChunk {
    s.warnings = append(s.warnings, problem{s.lineNum, "Content finished but chunk not closed"})
}
---


@s Processing content: Send surviving lines to markdown

--- Send surviving lines to markdown
s.markdown.WriteString(line + "\n")
---


@s Outputting the code: Checking code chunks

We don't want to output the code and discover half we through we have
a problem with the assembly. So we'll do checks on it first. Checks will be:

* Is every top level chunk a named file? [To be implemented]
* Does every named chunk exist? [To be implemented]
* Make sure there are no circular inclusions. [To be implemented]

--- Package level declarations +=
type set map[string]bool

type tree struct {
    childrenOf map[string]set
    parentsOf map[string]set
}

---

First we'll compile our tree of chunk names.

--- Functions +=
func compileTree(chunks map[string]string) tree {
    tr := tree{
        childrenOf: make(map[string]set),
        parentsOf: make(map[string]set),
    }
    for name, content := range chunks {
        // Make sure this parent is in the tree
        if tr.childrenOf[name] == nil {
            tr.childrenOf[name] = make(map[string]bool)
        }
        if tr.parentsOf[name] == nil {
            tr.parentsOf[name] = make(map[string]bool)
        }

        sc := bufio.NewScanner(strings.NewReader(content))
        for sc.Scan() {
            line := sc.Text()
            refChunk := referredChunkName(line)
            if refChunk == "" {
                continue
            }

            // Make sure this child is in the tree
            if tr.childrenOf[refChunk] == nil {
                tr.childrenOf[refChunk] = make(map[string]bool)
            }
            if tr.parentsOf[refChunk] == nil {
                tr.parentsOf[refChunk] = make(map[string]bool)
            }

            // Store the parent/child relationship
            (tr.childrenOf[name])[refChunk] = true
            (tr.parentsOf[refChunk])[name] = true
        }
    }
    return tr
}

func referredChunkName(str string) string {
    str = strings.TrimSpace(str)
    if strings.HasPrefix(str, "@{") && strings.HasSuffix(str, "}") {
        return strings.TrimSpace(str[2:len(str)-1])
    }
    return ""
}
---

